---

id: global-store-example-deckbuilder
title: Global Store – Example: Deckbuilder
description: How to use global-store for card-based games with quantity-based collections, match decks, and unlock tracking.
version: 0.2.4
category: phaser-plugin
status: active

---

## 🃏 Deckbuilder – Example Usage

This example demonstrates how to track a **large, quantity-based card collection** and manage per-match deck state in a deckbuilding game.

It distinguishes between **persistent meta-state** (`meta.collection`, `meta.permanentUpgrades`) and **ephemeral match state** (`match.deck`, `match.hand`, etc.), and shows how to track card ownership, match performance, and unlock conditions.

---

### 🧠 Recommended Key Structure

```ts
// 📚 Meta Collection (owned card IDs + quantity)
meta = {
  collection: {
    'strike': 12,
    'defend': 8,
    'fireball': 3,
    'focus': 2,
    'poison-dart': 1
  },
  unlockedRelics: ['draw-boost', 'potion-bag'],
  permanentUpgrades: {
    drawBonus: 1,
    startingHP: 80
  },
  winStreak: 3,
  dailyModes: ['mirror-draft', 'extreme-debuff']
};

// 🎴 Match State (cleared after every run)
match = {
  deck: ['strike', 'strike', 'strike', 'defend', 'fireball', 'fireball'],
  hand: ['defend', 'fireball'],
  discard: [],
  drawPile: ['strike', 'fireball'],
  hp: 52,
  turn: 4,
  relics: ['potion-bag'],
  modifiers: ['no-healing', 'double-enemies'],
  seed: 'daily-712x',
  draftPool: ['focus', 'poison-dart', 'strike']
};

// 📦 Save Metadata
saveMeta = {
  slotId: 2,
  createdAt: 1720584421
};
```

---

### 📈 Adding Cards to Collection

```ts
// Gain a card from a win
const qty = globalStore.get('meta.collection.poison-dart') || 0;
globalStore.set('meta.collection.poison-dart', qty + 1);
```

```ts
// Add duplicate of existing card
const strikeQty = globalStore.get('meta.collection.strike');
globalStore.set('meta.collection.strike', strikeQty + 3);
```

---

### 🎴 Deck and Hand Example

```ts
// Discard the first card in hand
const hand = globalStore.get('match.hand');
const discard = globalStore.get('match.discard');
globalStore.set('match.hand', hand.slice(1));
globalStore.set('match.discard', [...discard, hand[0]]);
```

```ts
// Draw next card from drawPile
const pile = globalStore.get('match.drawPile');
const newHand = [...globalStore.get('match.hand'), pile[0]];
globalStore.set('match.hand', newHand);
globalStore.set('match.drawPile', pile.slice(1));
```

---

### 🔁 Match Reset Pattern

```ts
// End match and clear state
globalStore.delete('match');

// Update win streak
const streak = globalStore.get('meta.winStreak');
globalStore.set('meta.winStreak', streak + 1);
```

---

### 🔓 Unlock New Card from Match Logic

```ts
// Unlock "focus" if turn ≥ 10
globalStore.onChange('match.turn', (turn) => {
  if (turn >= 10) {
    const current = globalStore.get('meta.collection.focus') || 0;
    if (current === 0) {
      globalStore.set('meta.collection.focus', 1);
    }
  }
});
```

---

### 🧠 Design Tip – Large Card Collections

For large, expandable card systems:

* Store cards by **ID + quantity** in `meta.collection`
* Decks should be **arrays of IDs**, including duplicates
* Match logic operates on references only — all metadata comes from a static catalog
* Avoid object mutation — always replace arrays when updating hand, deck, discard
* Draft logic should **not mutate** the collection — only permanent acquisition does

> ✅ Use `.dump()` before save and `.delete('match')` to reset per session

---

### 🧠 Object Schema Examples

#### 📚 Card Collection

```ts
meta.collection = {
  'strike': 12,
  'defend': 8,
  'fireball': 3,
  'focus': 2
};
```

#### 🎴 Match Deck & Hand

```ts
match = {
  deck: ['strike', 'strike', 'defend', 'fireball', 'focus'],
  hand: ['fireball', 'focus'],
  discard: ['defend'],
  drawPile: ['strike'],
  hp: 52,
  turn: 4,
  relics: ['potion-bag']
};
```

---

### ✅ Plugin Alignment Table

| Rule                   | Coverage                                      |
| ---------------------- | --------------------------------------------- |
| Meta vs session state  | ✅ `meta.*` vs `match.*` separation            |
| Atomic updates         | ✅ No in-place mutation                        |
| Object schemas         | ✅ Collection, deck, hand, discard, relics     |
| Save integration ready | ✅ Uses `.dump()` and `.delete('match')`       |
| Event reactivity       | ✅ Unlock logic and win streak tracking        |

---

### 🔗 See Also

* `example-roguelite.mdc` for long-term unlocks and depth tracking
* `anti-patterns.mdc` for common structure and mutation issues
```
