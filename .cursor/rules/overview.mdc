---

id: global-store-overview
title: Global Store – Overview
description: Core design goals, key patterns, and usage philosophy for the global-store plugin.
version: 0.2.4
category: phaser-plugin
status: active
alwaysApply: true
---

## 🌐 What Is Global Store?

**Global Store** is a simple, reactive key-value store for Phaser games.

It lets you:
- Share state between scenes
- Watch for changes (`onChange`)
- Store nested data using dot-paths
- Avoid tangled scene variables or awkward JSON objects

It’s designed for **clarity and control**, not magic frameworks.

---

## 🧱 Plugin Philosophy

| Principle              | Description |
|------------------------|-------------|
| ⚡ Simple API          | `.get()`, `.set()`, `.onChange()` – that’s it |
| 🧱 Structured State     | Dot-paths, not flat blobs (`player.hp`, `farm.plots.2`) |
| 🔁 Reactive            | Register triggers for key changes |
| 💾 Save-Ready         | Works with `dump()` / `reset()` for save/load |
| 🧠 Plugin-Agnostic     | Integrates cleanly with UI, dialogue, or combat plugins |
| 🔍 Transparent         | You own all game logic — no black box state |

---

## 🧠 How to Structure Your Store

Organize state around **scope and permanence**:

| Namespace | Use For |
|-----------|---------|
| `meta.*`  | Persistent progression – upgrades, unlocks, stats |
| `player.*` | Current stats – hp, coins, energy |
| `run.*` or `match.*` | Ephemeral gameplay state – combat, deck, round data |
| `scene.*` | Per-area flags – visited, cutscene played |
| `daily.*` | Temporary 24-hour game flags – cookedToday, petDog |
| `inventory.*` | Player items, seeds, currencies |
| `npcAffinity.*` | Relationship scores by ID |
| `farm.plots.*` | Named or ID-based slot systems |
| `meta.collection.*` | Quantity-based systems (cards, relics, recipes) |

---

## 🔑 Common Patterns

### ✅ ID-Only Tracking (for scalable unlocks)

```ts
store.set('meta.unlockedRelics', ['dash-stone', 'revive-charm']);
```

### ✅ Quantity Maps (for card collections, inventory)

```ts
store.set('meta.collection', {
  strike: 12,
  fireball: 3,
  focus: 2
});
```

### ✅ Dot-path State

```ts
store.set('farm.plots.3.watered', true);
store.set('scene.village.cutsceneSpringFestival', false);
```

### ✅ Resetting Ephemeral State

```ts
store.delete('match');
store.set('match', {
  deck: ['strike', 'defend'],
  hp: 30
});
```

---

## 🚫 Common Mistakes

See [`anti-patterns.mdc`](./antipatterns.mdc) for warnings about:

- In-place mutation of `.get()` results
- Using `hasThing` booleans instead of ID arrays
- Overwriting entire nested objects like `inventory`
- Storing full objects instead of IDs

---

## 📚 Learn by Example

| Example File | Genre |
|--------------|--------|
| `example-visual-novel.mdc` | Branching flags, relationship tracking |
| `example-turn-based-rpg.mdc` | Meta vs battle state separation |
| `example-farming-sim.mdc` | Crops, animals, weather, daily routines |
| `example-roguelite.mdc` | Meta unlocks, run state, death logs |
| `example-deckbuilder.mdc` | Large collection systems, match decks |

> Each file includes realistic schemas, reactivity, and reset logic.

---

## 💡 When to Use Global Store

Use it when:
- You need to persist values between scenes
- You want to react to changing values (e.g. quest progress, shop unlocks)
- You’re building complex state trees and want clean organization
- You want save/load compatibility without extra tools

Don’t use it for:
- **Ephemeral animations**
- **Scene-only object references** (cameras, tweens, physics bodies)

---

## 🔗 See Also

- [`usage.mdc`](./usage.mdc) – `.get`, `.set`, `.onChange` API reference
- [`anti-patterns.mdc`](./antipatterns.mdc) – What not to do
- [`todo.mdc`](./todo.mdc) – Plugin roadmap and polish goals
```

