---
description: Roadmap of the project
globs: 
alwaysApply: true
id: global-store-todo
title: Global Store – Roadmap & TODO
version: 0.2.5
category: phaser-plugin
status: active

---

## ✅ PHASE 1 – Core Design & Rule Definitions

- [x] Lock naming convention: dot-path keys, deep nested structures
- [x] Confirm plugin scope: dev-managed, singleton, in-memory only
- [x] Decide: no auto-persist — save/load must be explicit (`dump` / `reset`)
- [x] Confirm: no Proxies, no deep observation — favors performance and clarity
- [x] Define namespaces: `meta`, `match`, `inventory`, `npcAffinity`, etc.
- [x] Decide plugin is format-agnostic — schema is dev-defined
- [x] Decide all data must be serializable — no tweens, cameras, refs
- [x] Create `.mdc` structure for examples and rules (AI-facing, not docs)
- [x] Write all genre-specific examples:
  - [x] Visual Novel
  - [x] Turn-Based RPG
  - [x] Farming Sim
  - [x] Roguelite
  - [x] Deckbuilder
  - [x] Idle Clicker
  - [x] Metroidvania
- [x] Write core rule files:
  - [x] `usage.mdc`
  - [x] `overview.mdc`
  - [x] `antipatterns.mdc`
  - [x] `todo.mdc`
- [x] Define `.configure({ warnOnMutation, strict })` as planned options
- [x] Define clear structure for `.onChange`, `.offChange`
- [x] Decide `.mdc` files are not public docs — they drive agent output only

---

## 🔁 PHASE 2 – Plugin Code Implementation

> Everything below refers to actual code, not structural rules.

### 🧱 Core Features

- [ ] Create `GlobalStore` class - `new GlobalStore()`
- [ ] Support `set`, `get`, `has`, `delete`
- [ ] Support nested key paths (e.g. `player.hp`, `farm.plots.3.watered`)
- [ ] Implement `reset()` and `dump()`
- [ ] Implement `load(snapshot)` to restore full state
- [ ] Add `onChange(key, callback)` listener system
- [ ] Add `offChange(key, callback)` for cleanup
- [ ] Only trigger `onChange` when value changes by identity (`!==`)

### ⚙️ Configuration & Validation

- [ ] Implement `.configure({ warnOnMutation })`
- [ ] Implement `.configure({ strict })`
- [ ] Validate key paths in strict mode (e.g., no `''`, `null`, or invalid nesting)
- [ ] Block dangerous keys like `__proto__`, `constructor`, `prototype`
- [ ] Optionally warn on excessive nesting depth
- [ ] Add optional `has(key)` helper
- [ ] Consider utility: `merge(key, partialObject)` with shallow fallback

### 🧪 Dev & Type Safety

- [ ] Write all public methods in TypeScript
- [ ] Export full public types (via `index.d.ts` or inline with ESM)
- [ ] Add JSDoc comments for all methods and config options
- [ ] Write tests for:
  - [ ] core API
  - [ ] `.onChange` / `.offChange`
  - [ ] strict mode rejections
  - [ ] warnOnMutation triggers

---

## 🔁 PHASE 3 – Human-Facing Documentation

> The `.mdc` files are AI-facing rules only. These tasks refer to user-facing docs.

### 📘 README.md

- [ ] Add install instructions + usage of `new GlobalStore()` (and singleton usage if preferred)
- [ ] Add `set`, `get`, `onChange`, `delete`, `reset`, `dump` examples
- [ ] Include `.configure({ warnOnMutation, strict })` in usage
- [ ] Add section: "How to Structure Your Store" (dot-path naming, examples)
- [ ] Add "Save/Load with `save-kit`" example (`dump` + `reset`)
- [ ] Add comparison table: GlobalStore vs Redux vs Zustand vs Phaser Registry
- [ ] Add FAQ: Why not reactive Proxies? Why not use Redux?

### 📄 Additional Docs

- [ ] Create `USAGE.md` for detailed method references and warnings
- [ ] Create `ANTI-PATTERNS.md` with real-world bad vs good examples
- [ ] Add quick-start: 10-line snippet with `set`, `get`, `onChange`
- [ ] Add “bulk cleanup pattern” for listener-heavy scenes
- [ ] Add “Dev Guide” outlining `.configure`, test tips, listener strategies
- [ ] Add “Design Considerations” explaining reference equality, no Proxies, etc.


- [ ] Add “Glossary” section to README.md
  - [ ] Clarify naming intent: `npcAffinity.charId = score`, `farm.plots = { [id]: { crop, watered } }`
  - [ ] Define key schema terms: `meta`, `match`, `inventory`, `npcAffinity`, etc.
  - [ ] Explain state categories: persistent vs resettable vs ephemeral, etc
  - [ ] Helps devs understand structure philosophy at a glance
---

## 🔁 PHASE 4 – Demo Project: *The Camp and the Shrine*

- [ ] Scene: **Campfire**
  - Modify `player.name`, `settings.audio.muted`
  - View/edit `player.inventory`
  - “Sleep” button sets `player.hp = 100`
  - “Enter Shrine” button transitions to Shrine scene

- [ ] Scene: **Shrine Interior**
  - Simulate enemy combat → damages `player.hp` every 2s
  - Uses `onChange()` to update UI
  - Unlock a door if `player.inventory.includes('old_key')`
  - Sets `world.shrine.secretRoomUnlocked = true`
  - Button: Return to Campfire

- [ ] Scene: **Shrine Secret Room**
  - Only accessible if `world.shrine.secretRoomUnlocked === true`
  - Reward: Adds `amulet` to `player.inventory`
  - Shows full `globalStore.dump()` state

- [ ] Global Debug Overlay (optional)
  - Shows `globalStore.dump()` as JSON
  - Logs every triggered `onChange()` with timestamps

## 🧭 Future Features & Stretch Ideas

- [ ] Add optional Phaser Scene mixin for auto-cleanup of `onChange` listeners
- [ ] Add benchmarking suite (100 keys, 1K, 10K keys under mutation stress)

