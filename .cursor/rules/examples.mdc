---
description: 
globs: 
alwaysApply: false
---
---
id: global-store-examples
title: Global Store â€“ Real Game Examples
version: 0.1.0
category: phaser-plugin
status: active
---

## ğŸ® Real-World Usage by Genre

The goal of this file is to provide **copy-pastable state patterns** and examples for common game types.

Each section should show:

- ğŸ§  Recommended key structure
- ğŸ§ª Real-world use cases
- ğŸ›  Working code examples (`set`, `get`, `onChange`)
- ğŸ’¡ Optional pro tips

---

### ğŸ“– Visual Novel

---

#### ğŸ§  Recommended Key Structure

```ts
flags.metInnkeeper = true
flags.readNoteFromSister = false
choices.chapter3 = 'forgive'
choices.log = ['intro.friendly', 'scene2.tease']
scene.endingChosen = 'betrayal'
settings.textSpeed = 'medium'
ui.hasSeenIntroTooltip = true
```

---

#### ğŸ§ª Common Use Cases

- Track major and minor story branches
- Log player decisions for credits or reactivity
- Enable/disable dialogue or options based on past choices
- Gate scenes or endings behind flags
- Tweak settings and persistent UI state

---

#### ğŸ›  Example Code

```ts
// Mark a flag
globalStore.set('flags.readNoteFromSister', true);

// Save a major story choice
globalStore.set('choices.chapter3', 'forgive');

// Append to a log of player choices
const currentLog = globalStore.get('choices.log') ?? [];
globalStore.set('choices.log', [...currentLog, 'chapter3.forgive']);

// Watch for ending being chosen
globalStore.onChange('scene.endingChosen', (ending) => {
  if (ending === 'betrayal') {
    this.cameras.main.shake(300);
  }
});
```

---

#### ğŸ’¡ Pro Tips

- Use `flags.` for binary decisions
- Use `choices.` for narrative branches and UI labels
- Log player paths into `choices.log[]` for analytics, recaps, or debugging
- Use `ui.` for tooltips and one-time visual interactions
- Avoid storing current character animations, timers, etc.

---

## ğŸ—‚ï¸ Genres to Flesh Out Later

The following game types should each receive their own section, following the format above:

| Genre | Notes |
|-------|-------|
| ğŸ§© Block Puzzle | Boosters, powerups, level stars, coins, timers |
| ğŸ Racing Game | Cars unlocked, best times, controls config |
| âš”ï¸ Turn-based RPG | Quests, party HP, inventory, towns visited |
| ğŸ—º Metroidvania | Abilities unlocked, map rooms, key items |
| ğŸ® Fighting Game | Character unlocks, input config, ranked stats |
| ğŸ‘¾ Roguelike | Meta progress, unlock trees, seed history |
| ğŸ“± Mobile idle game | Global upgrades, ad timers, prestige count |
| ğŸ¤ Rhythm Game | Song high scores, options, unlocked difficulties |
| ğŸ’¬ Dating Sim | Affection levels, scenes seen, special flags |
| ğŸ§  Puzzle platformer | Level state, switches flipped, items collected |
| ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ Family sim / builder | Resources, happiness, relationship meters |

---

## ğŸ§  Guiding Philosophy

The global store isnâ€™t a database or logic system. Itâ€™s a simple in-memory state layer â€” perfect for tracking player progress, choices, and world state across scenes.

Use it like youâ€™re structuring your gameâ€™s save file: clear, shallow, namespaced keys â€” nothing complex or deeply nested unless necessary.

"Design your keys like save data" = Use the same structure youâ€™d expect in a save file:

âœ… Good:

```ts
player.hp = 100
player.inventory = ['sword', 'key']
world.rooms.cleared = ['hallway']
```

âŒ Bad:

```ts
animationState.current = 'idle' // scene-specific
player.logicClass = new Player() // non-serializable
tempFlags.clearTooltip = true // one-off local flag
```

---
