---

id: global-store-example-visual-novel
title: Global Store – Example: Visual Novel
description: How to use global-store in branching, choice-driven narrative games.
version: 0.2.3
category: phaser-plugin
status: active
--------------

## 📘 Visual Novel – Example Usage

This example covers **branching dialogue**, **player choices**, and **persistent world state** in a visual novel or dialogue-heavy narrative game.

It separates permanent player progress (choices made, flags triggered) from current scene/session state.

---

### 🧠 Recommended Key Structure

```ts
// 📖 Persistent story flags
flags.story.metInnkeeper = true;
flags.story.escapedWolves = true;
flags.story.accusedMayor = false;

// 🧠 Character relationship tracking (optional)
meta.affinity = {
  innkeeper: 4,
  mayor: -2
};

// 💌 Player choices
choices = {
  openingQuestion: 'Who are you?',
  mealSelection: 'Stew',
  innkeeperFlirted: true
};

// 📍 Current scene/session state (ephemeral)
scene = {
  id: 'scene_07_well',
  scrollY: 220,
  selectedLine: 3
};

// 📦 Save metadata (optional)
saveMeta = {
  lastSave: '2025-07-15T14:30:00Z',
  playtime: 12900, // seconds
  chapter: 'Act 2 – The Quiet Inn'
};
```

---

### 📋 Example: Storing Player Decisions

```ts
globalStore.set('choices.innkeeperFlirted', true);
```

### 🔁 Tracking Relationships

```ts
const affinity = globalStore.get('meta.affinity.innkeeper') || 0;
globalStore.set('meta.affinity.innkeeper', affinity + 1);
```

### 🎯 Branching Dialogue Example

```ts
if (globalStore.get('flags.story.metInnkeeper')) {
  showLine("Nice to see you again.");
} else {
  showLine("Welcome, traveler.");
}
```

### 💬 Restoring Scene State (scroll position, last selected)

```ts
const { scrollY, selectedLine } = globalStore.get('scene');
dialogUI.restore(scrollY, selectedLine);
```

### 🔔 Reacting to Key Plot Events

```ts
// React to an ending being chosen
globalStore.onChange('scene.endingChosen', (ending) => {
  if (ending === 'betrayal') {
    this.cameras.main.shake(300);
  }
});
```

---

### 💡 Design Tips

* Use `flags.story.*` for **narrative state**, not UI
* Use `choices.*` for **actual selections made**
* Use `meta.affinity.*` for numerical tracking
* Always treat updates as **atomic replacements**
* Clear ephemeral `scene.*` state when transitioning between chapters

> ✅ The global store is ideal for save systems — you can `dump()` to JSON and restore using `reset()`

---

### 🧠 Object Schema Examples

#### 💘 Affinity Structure

```ts
meta.affinity = {
  innkeeper: 4,
  mayor: -1,
  blacksmith: 0
};
```

#### 🗂 Scene Save Snapshot

```ts
scene = {
  id: 'scene_04_meadow',
  scrollY: 120,
  selectedLine: 2
};
```

#### 🏷 Choice Storage

```ts
choices = {
  firstMeal: 'chicken',
  flirtedWithInnkeeper: true
};
```

---

### ✅ Plugin Alignment Table

| Rule                    | Coverage                                   |
| ----------------------- | ------------------------------------------ |
| Meta vs ephemeral state | ✅ `flags.*` vs `scene.*`                   |
| Atomic update examples  | ✅ All data replacements use set()          |
| Typed example objects   | ✅ `meta`, `scene`, `choices` schemas shown |
| Save integration ready  | ✅ Uses clean dump/reset structure          |
| Relationship tracking   | ✅ Via `meta.affinity.*`                    |

---

### 🔗 See Also

* `example-turn-based-rpg.mdc` for HP/stats/equipment
* `example-deckbuilder.mdc` for card-based progression
* `anti-patterns.mdc` for mutation and listener pitfalls
