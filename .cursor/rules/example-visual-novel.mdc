---

id: global-store-example-visual-novel
title: Global Store â€“ Example: Visual Novel
description: How to use global-store in branching, choice-driven narrative games.
version: 0.2.3
category: phaser-plugin
status: active
--------------

## ğŸ“˜ Visual Novel â€“ Example Usage

This example covers **branching dialogue**, **player choices**, and **persistent world state** in a visual novel or dialogue-heavy narrative game.

It separates permanent player progress (choices made, flags triggered) from current scene/session state.

---

### ğŸ§  Recommended Key Structure

```ts
// ğŸ“– Persistent story flags
flags.story.metInnkeeper = true;
flags.story.escapedWolves = true;
flags.story.accusedMayor = false;

// ğŸ§  Character relationship tracking (optional)
meta.affinity = {
  innkeeper: 4,
  mayor: -2
};

// ğŸ’Œ Player choices
choices = {
  openingQuestion: 'Who are you?',
  mealSelection: 'Stew',
  innkeeperFlirted: true
};

// ğŸ“ Current scene/session state (ephemeral)
scene = {
  id: 'scene_07_well',
  scrollY: 220,
  selectedLine: 3
};

// ğŸ“¦ Save metadata (optional)
saveMeta = {
  lastSave: '2025-07-15T14:30:00Z',
  playtime: 12900, // seconds
  chapter: 'Act 2 â€“ The Quiet Inn'
};
```

---

### ğŸ“‹ Example: Storing Player Decisions

```ts
globalStore.set('choices.innkeeperFlirted', true);
```

### ğŸ” Tracking Relationships

```ts
const affinity = globalStore.get('meta.affinity.innkeeper') || 0;
globalStore.set('meta.affinity.innkeeper', affinity + 1);
```

### ğŸ¯ Branching Dialogue Example

```ts
if (globalStore.get('flags.story.metInnkeeper')) {
  showLine("Nice to see you again.");
} else {
  showLine("Welcome, traveler.");
}
```

### ğŸ’¬ Restoring Scene State (scroll position, last selected)

```ts
const { scrollY, selectedLine } = globalStore.get('scene');
dialogUI.restore(scrollY, selectedLine);
```

### ğŸ”” Reacting to Key Plot Events

```ts
// React to an ending being chosen
globalStore.onChange('scene.endingChosen', (ending) => {
  if (ending === 'betrayal') {
    this.cameras.main.shake(300);
  }
});
```

---

### ğŸ’¡ Design Tips

* Use `flags.story.*` for **narrative state**, not UI
* Use `choices.*` for **actual selections made**
* Use `meta.affinity.*` for numerical tracking
* Always treat updates as **atomic replacements**
* Clear ephemeral `scene.*` state when transitioning between chapters

> âœ… The global store is ideal for save systems â€” you can `dump()` to JSON and restore using `reset()`

---

### ğŸ§  Object Schema Examples

#### ğŸ’˜ Affinity Structure

```ts
meta.affinity = {
  innkeeper: 4,
  mayor: -1,
  blacksmith: 0
};
```

#### ğŸ—‚ Scene Save Snapshot

```ts
scene = {
  id: 'scene_04_meadow',
  scrollY: 120,
  selectedLine: 2
};
```

#### ğŸ· Choice Storage

```ts
choices = {
  firstMeal: 'chicken',
  flirtedWithInnkeeper: true
};
```

---

### âœ… Plugin Alignment Table

| Rule                    | Coverage                                   |
| ----------------------- | ------------------------------------------ |
| Meta vs ephemeral state | âœ… `flags.*` vs `scene.*`                   |
| Atomic update examples  | âœ… All data replacements use set()          |
| Typed example objects   | âœ… `meta`, `scene`, `choices` schemas shown |
| Save integration ready  | âœ… Uses clean dump/reset structure          |
| Relationship tracking   | âœ… Via `meta.affinity.*`                    |

---

### ğŸ”— See Also

* `example-turn-based-rpg.mdc` for HP/stats/equipment
* `example-deckbuilder.mdc` for card-based progression
* `anti-patterns.mdc` for mutation and listener pitfalls
